\documentclass[12pt,a4paper]{article}
% -- LuaLaTeX --

\usepackage{qsettings}
\usepackage{hyperref}

% настройки титульной страницы
\doctype{REP}

% \kafedra{Кафедра вычислительных систем и сетей}

\profrank{доцент, канд. техн. наук.} % проф., д.т.н.
\profname{Д. С. Дехканбаев}  % А. В. Гордеев

\docsubject{Создание параллельного приложения с помощью MPI} % тема отчета
\docdiscip{Параллельные вычисления} % название предмета (дисциплины)

\studclass{4645М} % номер группы
\studname{Г. В. Гетманенко} % имя студента

\docfooter{\the\year} % футер титульной страницы (e.g. СПб, 2015)

%\nofiles

%\directlua{ require("drawboxes")}\usepackage{atbegshi}\AtBeginShipout {\directlua{drawboxes.visual_debug()}}


% ---------- НАЧАЛО ДОКУМЕНТА ----------


\begin{document}
\makeqtitle
\setcounter{page}{2}

\section{Цель работы}

Приобретение навыков написания параллельных программ. Знакомство с MPI.

\section{Задание}

Вариант 1: Написать программу, генерирующую множество точек, равномерно
заполняющих круг. Точки необходимо сохранять в файл. Число точек задается
пользователем.

\section{Теоретические сведения}

Генерацию точек, равномерно заполняющих круг, можно провести следующим алгоритмом:

\begin{enumerate}
    \item Сгенерировать два множества чисел с равномерным распределением от нуля до единицы. \\
          Первое множество $A$ представляет угол, второе $R$ - расстояния от центра круга.
    \item Заменить значения $R$ на квадратный корень каждого значения: $r_i' = \sqrt{r_i}$. \\
          Это равномерно распределит точки по кругу, задающиеся в полярной системе координат
          парами $(\alpha_i, r_i)$ из множеств $A$, $R$.
    \item Значения случайных углов $A$ необходимо умножить на необходимый радиус круга,
          а значения $A$ умножить на $2\pi$, чтобы привести к диапазону $(0; 2\pi)$.
    \item Вычислить координаты точек в декартовой системе координат: $x_i = \cos(\alpha_i) \cdot r_i,\, y_i = \sin(\alpha_i) \cdot r_i$.
\end{enumerate}


\section{Реализация программы}

Посколько при большом количестве единовременно генерируемых точек (речь о количестве порядка $10^7$)
количество потребляемой памяти может достигать нескольких сотен мегабайт, предлагается
генерировать точки частями - чанками.

Как вариант реализации, для сохранения очередного чанка процессу необходимо:

\begin{enumerate}
    \item Отправить на процесс с нулевым ранком или оставить у себя, если используем раздельный доступ к файлу.
    \item Создать представление сгенерированных точек в виде строки, которая будет сохранена в файл (форматирование).
    \item Записать полученную строку в файл.
\end{enumerate}

Альтернативно, поскольку форматирование тоже требовательный процесс, была скорректирована реализация
программы, в которой строка форматируется в том же процессе, в котором она и генерируется. То есть,
пункты первые два пункта из списка выше переставлены местами.


\section{Проверка производительности}

Программа написана на языке Python 3.6, поскольку автор работы решил, что
знания по работе с MPI на Python в будущем пригодятся ему больше, чем C++.
Исходный код программы можно посмотреть на GitHub: \\
\url{https://github.com/MrP4p3r/guap-mag-s3/tree/master/mpi}.

Для проверки производительности был написан небольшой скрипт, который
можно так же увидеть на GitHub. Были запущены четыре теста для каждой
реализации, для каждого количества процессов (1-8), для каждого количества
точек из множества ($1$, $10$, ..., $10^7$). 

При выполнении программы замерялось время непосредственно с начала генерации
точек всеми процессами, до конца работы алгоритма всеми процессами. Для
этого была использована синхронизациия через \verb'MPI_Barrier'.
Результаты тестов можно увидеть ниже.

\newpage

\begin{Verbatim}
$ # Сначала форматирование, пересылка, потом пишет RANK=0
$ ./performance-test.py ./generate-format-send-write.py
\end{Verbatim}
\easyverbnl[firstnumber=0]{./test-results/format-send/out.txt}
\easypic{./test-results/format-send/fig.png}{}{0.8}

\newpage

\begin{Verbatim}
$ # Сначала форматирование, потом пишет каждый процесс
$ ./performance-test.py ./generate-format-send-write.py -d
\end{Verbatim}
\easyverbnl[firstnumber=0]{./test-results/format-send/out-d.txt}
\easypic{./test-results/format-send/fig-d.png}{}{0.8}

\newpage

\begin{Verbatim}
$ # Сначала пересылка, форматирование, пишет RANK=0
$ ./performance-test.py ./generate-send-format-write.py
\end{Verbatim}
\easyverbnl[firstnumber=0]{./test-results/send-format/out.txt}
\easypic{./test-results/send-format/fig.png}{}{0.8}

\newpage

\begin{Verbatim}
$ # Форматирование, пишет каждый
$ ./performance-test.py ./generate-send-format-write.py -d
\end{Verbatim}
\easyverbnl[firstnumber=0]{./test-results/send-format/out-d.txt}
\easypic{./test-results/send-format/fig-d.png}{}{0.8}


\section{Вывод}

Самой эффективной реализацией программы оказался, что не удивительно,
вариант с предварительным форматированием. Причем при записи в файл только
из процесса с RANK=0. Вариант с распределенной записью работает приблизительно
на 30\% дольше. Варианты с форматированием после коммуникации работают
значительно медленнее.

Пологая часть графиков связана с размером чанка в 1024 точки. Если уменьшить размер
чанка до, скажем, четырех точек, скорость выполнения программы значительно уменьшится,
а форма графика станет более прямой. Варьируя размер чанка, можно попробовать
найти золотую середину для большей скорости работы программы при незначительном
потреблении памяти.

\end{document}

